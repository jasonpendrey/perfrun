#!/usr/bin/env ruby
require 'optparse'
require_relative 'drivers/provider'
require_relative 'spindriver'

class Spinup
  CONFIG = "config/spinup.json"
  CRED_CONFIG = "config/credentials.config"

  @debug = false
  @mode = 'run'
  @verbose = 0
  @dryrun = false
  @threads = []
  @config = CONFIG
  
  def self.oneoffrun     
    @objs.each do |obj|
      next if obj['compute_scopes'].length == 0
      if ARGV.length > 0
        prov = obj['provider']['cloud_driver']
        next if ! ARGV.include? prov
      end
      runone obj
    end
    waitthreads
  end
  
  def self.runone obj
    prov = obj['provider']['name']
    loc = obj['provider']['location_flavor'] || obj['provider']['address']
    opts = {}
    opts[:verbose] = @verbose
    opts[:object] = obj
    opts[:tags] = @tags
    opts[:mode] = @mode
    opts[:app_host] = @app_host if @app_host
    puts "#{@mode.capitalize} #{obj['name']}@#{prov}/#{loc} using #{@config}"
    if @mode == 'run' or @mode == 'delete'
      curthread = {started_at:Time.now, prov: prov, loc: loc}
      curthread[:thread] = Thread.new {    
        curthread[:thread] = Thread.current
        curthread[:pd] = pd = SpinDriver.new
        pd.run opts do |scope, fullname, id, ip|
          # XXX need to rationalize this to call an external hook
          puts "#{id}: #{fullname} #{ip}"
          puts RackspaceDriver.del_dns "burstorm.com", fullname
          puts RackspaceDriver.add_dns "burstorm.com", fullname, ip
        end
        delthread curthread
      }
      @mutex.synchronize do
        @threads.push curthread unless curthread[:dead]
      end
    else
      pd = SpinDriver.new
      pd.verbose = @verbose
      pd.run opts
    end
  end


  def self.main
    @mutex = Mutex.new
    if ARGV.length > 0
      OptionParser.new do |o|
        o.on('--app_host HOST') { |b|
          @app_host = b
        }
        o.on('--delete') { |b|
          @mode = 'delete'
        }
        o.on('--list', '-l') { |b|
          @mode = 'list'
        }
        o.on('--verbose', '-v') { |b|
          @verbose = 1
        }
        o.on('--dryrun') { |b|
          @dryrun = true
        }
        o.on('--config CONFIG','-c CONFIG') { |b|
          @config = b
        }
        o.on('--knifelist') { |b|
          @mode = 'knifelist'
        }
        o.on('--debug') { |b|
          @debug = true
        }
        o.on('-h','--help') { |b|
          puts o
          exit 0
        }
      end.parse!
    end

    start = Time.now
    $LOAD_PATH.push "#{Dir.pwd}/config"
    begin
      load CRED_CONFIG
    rescue
    end
    begin      
      if File.exist? @config
        @project = JSON.parse File.read(@config)
      else
        @project = JSON.parse File.read('config/'+@config)
      end
    rescue Exception => e
      puts @config
      puts "config load error: #{e.message} #{e.backtrace.join('\n')}"
      exit 1
    end
    case @project['ptype']
    when 'contract'
      @objs = @project['contracts']
    when 'quote'
      @objs = @project['quotes']
    when 'objective'
      @objs = @project['objectives']
    else
      if @project['compute_scopes']
        @objs = [@project]
      else
        puts "Unknown project type: #{@project['ptype']}. Probably the wrong kind of JSON API file."
        puts @project.inspect
        exit 1
      end
    end
    @tags = @project['project_tags']
    oneoffrun
    puts "<b>Spinup finished after #{((Time.now-start)/60).round(1)} minutes</b>"
    exit 0
  end

  private

  def self.waitthreads
    puts "<b>Start waiting for #{@threads.length} threads: #{@threads.inspect}</b>" if @threads.length > 0 and @verbose > 0
    begin
      while @threads.length > 0
        @mutex.synchronize do 
          puts "-----------" if @verbose > 0
          now = Time.now
          @threads.each_with_index do |t, idx|
            if ! t[:thread].status or t[:dead]
              @threads.delete_at idx
              next
            end
            if @verbose > 0
              puts "waiting #{(now-t[:started_at]).round}s for #{t[:prov]}/#{t[:loc]} to finish (running #{((Time.now-t[:started_at])/60).to_i} minutes)" 
              puts t[:pd].status if t[:pd]
            end
          end
        end
        STDOUT.flush
        sleep 10
      end      
    rescue Exception => e
      puts "\n\n***Spinup: cleaning up because of #{e.inspect} ***"
      puts "#{e.backtrace.join "\n"}" if @verbose > 0
      @threads.each do |t|
        t[:pd].abort if t[:pd] 
      end
      @threads.each do |t|
        t[:pd].cleanup if t[:pd] 
      end
    end
  end
  

  def self.delthread thread
    @mutex.synchronize do 
      thread[:dead] = true
      @threads.each_with_index do |t, idx|
        next if t != thread
        @threads.delete_at idx
        break
      end
    end
  end

end

Spinup.main
